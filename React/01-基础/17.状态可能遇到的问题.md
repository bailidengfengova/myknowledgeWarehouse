1.setState调用完之后状态就立即更新了
    render函数才会重新执行，显示最新的页面效果

    而在render外的函数里，拿到的状态的之前的值

    同步与异步的问题
        constructor是异步
        render外的函数里是同步
2.setState是同步执行还是异步执行
    面试题？
        连续多次调用setState，页面如何更新？
            此时会发现setState处在同步的逻辑中是异步更新状态 异步的对比虚拟dom 异步更新真实dom
                比如在一个render外的函数里连续多次调用相同的setState
                    状态一直不变，比如count为1，一直为1，执行完之后才加1
        如果是同步的，就会卡住，后面的无法执行，所以为异步执行，空闲的时执行setState内操作

        专业说法
            为了性能考虑
                多次setState调用会进行合并处理，把几块合并成一块，所以说没有立即做状态的跟新
                    而是等一个事件循环结束之后，在下一个宏任务中更新状态
3.setTimeout(0)相当于异步操作
    setState放在setTimeout 0（异步逻辑中）里相当于同步更新状态 同步更新真实dom
4.React代码中有一个标志位
    在同步事件中会被置为true，表示现在是可以进行合并处理的，此时setState是异步，不会立即执行
        等着事件循环一直往下走，看能不能与其他的setState进行合并，等方法执行完之后，才会触发React中的交易机制，会合并处理，之后把标志位改成false
    异步过程中，支持合并的标志位被立即做成了false，不支持合并，不会阻塞线程执行（主线程的任务不会被阻塞），所以此时调一次立即执行一次
5.React方案：什么时候状态会更新完
    setState支持第二个参数
    this.setState({
        c: this.state.c + 1
    },() => {
        log c
        // 更新状态和真实DOM 完毕
    })
    如果log放在外面，会立即执行，不知道什么时候执行完