1.受控
    能通过一个属性完全驱动和控制子组件，就是受控组件，否则为非受控组件
2.为什么要父传子
    组件需要复用，需要属性传递，为了更好的实现复用
    通过属性传过去
3.为什么要子传父
    状态提升
        React的子传父的过程需要传个回调函数，是父组件传递给子组件的属性
    通过回调函数 callback
    子组件无法访问到父组件的状态，但是可以通知父组件进行操作
4.App组件的状态只能在组件内用
    状态时内部的，不可能给外面的用
        只能通过属性关联
5.如果子组件有自己的状态，在外面就不好控制
6.不要说用了一个子传父就是受控组件
    因为有自己的状态，所以不受外界控制
        只是使用了父子通信实现了组件化的结构思维
7.父组件传递的props可以重名，不同组件用的props不同
8.无法接收父组件的属性赋值给我当前的状态
    无法把父组件的属性给子组件的状态强行赋值
        如果强行赋值也仅仅在第一次创建状态的时候
            之后再怎么改值，确实可以传递给子组件，但是子组件里的state只有在类第一次创建的时候调用
                再次传过来只不过让子组件在更新一下，不会再创建一遍，只有render会重新再走一遍
                    无法把最新的属性给state赋值，此时子组件完全是不受控的行为
                与input非受控value类似 defaultValue就只是初始时更新
9.可以把无状态的类组件改成函数组件
    函数组件里的方法要放在return之前写
    props用形参传，放在形参里
    函数内部定义的方法前要加function
10.useEffect第二个参数为空数组
    意味着与cdm相同，初始化只执行一次，可以代替类中的cdm写
    之后添加依赖之后
        依赖变化，函数将会继续执行
11.函数式组件没有销毁的生命周期
    如果在cdm生命周期中有定时器，如何在销毁周期内销毁
        可以在useEffect的第一个回调函数的最后再return一个回调函数
            相当于一个闭包函数
                此函数执行的时间是函数销毁的时候，前提是没有依赖的时候
                    因为没有依赖的时候，整个useEffect函数只执行一次
                        就只执行一次
                    写了依赖，每次更新的时候，回调函数也会执行一次
                        就是更新和销毁的时候都会执行
12.此副作用函数
    通过第一个参数 第一个参数里的return函数 第二个数组
    可以模拟整个生命周期，从创建到更新到销毁的所有过程
13.useEffect在项目中可以用无数多次
    比都写在一个里面强
        不像生命周期，cdm写两次，后边的会覆盖前边的
            useEffect只是一个函数调用，所以可以写多个
14.useEffect与useLayoutEffect的区别
    常规情况无区别
        区别是调用时机不同
            useLayoutEffect与cdm和cdu更像一点
                特点
                    在DOM完成更新之后马上同步调用代码，会阻塞页面更新
                        刚完成DOM更新就会同步调用useLayoutEffect注册的回调函数（cdm中写的同步代码）
                        先DOM树，后渲染树
                            时机仅在DOM完成更新
                                DOM此时可能在内存中，只是把DOM更新完了，开始执行生命周期中的代码
                                    真正到渲染树的时候会阻塞，阻塞页面UI的渲染
                                    性能可能并不如useEffect好
                                        useEffect是在整个页面渲染完（DOM更新完，内存更新完）才会调用代码
        官方推荐使用useEffect
    但是
        在cdm,cdu中做纯DOM操作，特别推荐使用useLayoutEffect
            因为useEffect执行时机是页面渲染完，此时修改了DOM，页面需要再次进行回流和重绘
                可能会出现页面抖动的情况
            useLayoutEffect在DOM创建在内存中的时候会执行，此时做DOM操作，会与React中的DOM操作进行合并，而且会一次性的渲染到页面中，也就是只有一次回流和重绘的代价
    如果要在回调函数中做一点DOM操作，比如加一些动画
        在useEffect中做改动，可能出现页面已经更新了一次，又改动，继续更新，会引发多次回流
        在useLayoutEffect中做，DOM还在内存中，会合并一起更新，只有一次回流合并的代价